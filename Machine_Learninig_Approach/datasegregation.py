# -*- coding: utf-8 -*-
"""DataSegregation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12kPk_JZKlJPcXDpQi_cK3DeIIOow3LKU
"""

"""
This python script generates the data file for training SVM and 
random forest regressor models. It takes the csv data file (generated 
by dataFileGeneration.py) containing intensity, channel orientation, 
blue-yellow and red-green sub channel conspicuity values of at each 
pixel of every webpage screenshot in the training set and randomly 
selects 10 best positive (where eye fixation value for a pixel is >150) 
and 10 best negetive ((where eye fixation value for a pixel is <= 150)) 
values for each image in the training set to create a new CSV file 
to be used by machine learning models(SVM and random forest regressor).
"""

# Uncomment if using Google colab
# from google.colab import drive
# drive.mount('/content/drive')

import csv
import random
import numpy as np

"""
Function Name: chooseBestPositiveResults()
Functionalities: This function takes a list containing various conspicuity
                 information for a each pixel against the eyefixation values
                 of a webpage image, randomly picks 'n' items having eyefix-
                 ation >150. In our case n = 10. It returns a list containing
                 these n items.
Parameter:n, listToPickFrom
Returns: positiveResult

"""


def chooseBestPositiveResults(n, listToPickFrom):
    positiveResult = []
    while (len(positiveResult) < n):
        if len(listToPickFrom) == 1024:
            index = random.randint(0, 1023)
            if int(float(listToPickFrom[index][len(listToPickFrom[index]) - 1])) == 1:
                positiveResult.append(listToPickFrom[index])

        else:
            print("list is of size: ", len(listToPickFrom))
            break;

    return positiveResult


"""
Function Name: chooseBestNegetiveResults()
Functionalities: This function takes a list containing various conspicuity
                 information for a each pixel against the eyefixation values
                 of a webpage image, randomly picks 'n' items having eyefix-
                 ation <150. In our case n = 10. It returns a list containing
                 these n items.
Parameter:n, listToPickFrom
Returns: negetiveResult

"""


def chooseBestNegetiveResults(n, listToPickFrom):
    negetiveResult = []
    while (len(negetiveResult) < n):
        if len(listToPickFrom) == 1024:
            index = random.randint(0, 1023)
            if int(float(listToPickFrom[index][len(listToPickFrom[index]) - 1])) == 0:
                negetiveResult.append(listToPickFrom[index])

        else:
            print("list is of size: ", len(listToPickFrom))
            break;

    return negetiveResult


# list for collecting 10 best positive and 10 best negetive results for
# each image in the training set
dataArr = []

# csv file containing conspicuity information against eye fixation map for
# each image in the training set
DataFile = open('/content/drive/My Drive/HCI_prep/IttiKoch/data_32.csv', 'r')

# change the no. of best positive or negetive values here
n = 10
csvReader = csv.reader(DataFile)
imageIndex = 0
tempList = []
for row in csvReader:
    print(int(float(row[0])))

    if imageIndex != 105:

        if int(float(row[0])) == imageIndex:
            tempList.append(row)
            print(len(tempList))
            if len(tempList) == 1024:
                positiveResult = chooseBestPositiveResults(n, tempList)
                dataArr += positiveResult
                negetiveResult = chooseBestNegetiveResults(n, tempList)
                dataArr += negetiveResult
                # print("image index :", imageIndex)
                imageIndex += 1
                # print("image index after the operation :", imageIndex)
                tempList = []
                # continue;
                # continue

        if imageIndex == 140:
            break

    else:
        print("image index :", imageIndex)
        imageIndex += 1
        continue

DataFile.close()
# coverting list to numpy array
numpyArr = np.asarray(dataArr, dtype="float")

# saving the numpy array to .csv file to specified path
np.savetxt("/content/drive/My Drive/HCI_prep/IttiKoch/data_32_selected.csv", numpyArr, delimiter=",")
